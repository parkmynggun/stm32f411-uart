#include "motor.h"
#include "main.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define RX_BUF_SIZE 64   // 수신 버퍼 크기
#define SPEED_STEP 10    // PWM 점진 증가 값

uint8_t rxData = 0;          // HAL_UART_Receive_IT 용
uint8_t rxBuf[RX_BUF_SIZE];  // UART 수신 버퍼
volatile uint8_t rxIndex = 0;

// (다른 변수 선언들은 그대로 유지)
// ...

// UART 수신 라인 처리 (기존 코드와 동일, 문제 없음)
void ProcessReceivedLine(uint8_t *line)
{
    uint32_t values[4];

    if (sscanf((char*)line, "ADC:%u,%u,%u,%u", &values[0], &values[1], &values[2], &values[3]) == 4) {
        for (int i = 0; i < 4; i++)
            adc_scaled[i] = values[i];
    }
    else {
        // 버퍼 크기를 늘려 에러 메시지 잘림 방지
        char msg[RX_BUF_SIZE + 30];
        sprintf(msg, "[UART ERROR] Invalid line: %s\r\n", line);
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 50);
    }
}

// UART 인터럽트 (안정성 개선)
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        // 1. 버퍼 오버플로우 방지
        // null terminator를 위한 공간(1)을 남겨둠
        if (rxIndex < RX_BUF_SIZE - 1) {
            rxBuf[rxIndex++] = rxData;
        } else {
            // 버퍼가 가득 차면 인덱스를 리셋하여 데이터 덮어쓰기 방지
            rxIndex = 0;
        }

        // 2. 줄바꿈 문자로 라인 종료 확인
        if (rxData == '\n' || rxData == '\r') {
            // 3. 수신된 문자열의 끝을 명확히 처리 (null-termination)
            // 줄바꿈 문자 위치에 널 문자('\0')를 넣어 문자열의 끝을 표시
            if (rxIndex > 0) {
               rxBuf[rxIndex - 1] = '\0';
            } else {
               rxBuf[0] = '\0';
            }

            // 빈 줄이 아닐 경우에만 데이터 처리
            if (strlen((char*)rxBuf) > 0) {
                ProcessReceivedLine(rxBuf);
            }

            // 다음 라인을 위해 인덱스 초기화
            rxIndex = 0;
        }

        // 다음 1바이트 수신을 위해 인터럽트 다시 활성화
        HAL_UART_Receive_IT(&huart1, &rxData, 1);
    }
}


// (이하 다른 함수들은 그대로 유지)
// ...
