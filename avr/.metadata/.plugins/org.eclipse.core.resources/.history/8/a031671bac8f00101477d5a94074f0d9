#include "motor.h"
#include "main.h"
#include <stdlib.h>
#include <string.h>

uint8_t rxData = 0;                  // UART 1바이트 수신 변수
uint8_t toggleModeFlag = 0;          // 'x' 토글 플래그
volatile uint8_t newValueFlag = 0;   // 수신 완료 플래그
static uint32_t lastToggleTime = 0;  // 토글 디바운싱용

// ADC 2바이트 수신 버퍼
volatile uint8_t adcRxBuf[2] = {0};
volatile uint8_t adcByteIndex = 0;
volatile uint16_t rxADCValue = 0;    // 수신된 ADC 값

volatile uint16_t currentCcrLeft = 0;
volatile uint16_t currentCcrRight = 0;
volatile uint16_t targetCcrLeft = 0;
volatile uint16_t targetCcrRight = 0;
volatile uint16_t lastSpeed = 300;

volatile MotorMode_t currentMode = MODE_MANUAL;

// 모드 확인
MotorMode_t GetCurrentMode(void)
{
    GPIO_PinState pc1 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);
    GPIO_PinState pc0 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14);

    if (pc1 == GPIO_PIN_SET && pc0 == GPIO_PIN_RESET)
        return MODE_AUTO;
    else
        return MODE_MANUAL;
}

// UART 수신 ISR
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        uint32_t currentTime = HAL_GetTick();

        if (rxData == 'x') // 토글용
        {
            if (currentTime - lastToggleTime > 500)
            {
                toggleModeFlag = 1;
                lastToggleTime = currentTime;
            }
        }
        else
        {
            // 2바이트 ADC 수신
            adcRxBuf[adcByteIndex++] = rxData;
            if (adcByteIndex >= 2)
            {
                rxADCValue = ((uint16_t)adcRxBuf[0] << 8) | adcRxBuf[1];
                adcByteIndex = 0;
                newValueFlag = 1;
            }
        }

        HAL_UART_Receive_IT(&huart1, &rxData, 1); // 다음 수신 준비
    }
}

// PWM 점진 적용
void UpdateMotorSpeed(void)
{
    if (currentCcrLeft < targetCcrLeft)
        currentCcrLeft = (currentCcrLeft + SPEED_STEP > targetCcrLeft) ? targetCcrLeft : currentCcrLeft + SPEED_STEP;
    else if (currentCcrLeft > targetCcrLeft)
        currentCcrLeft = (currentCcrLeft < SPEED_STEP + targetCcrLeft) ? targetCcrLeft : currentCcrLeft - SPEED_STEP;

    if (currentCcrRight < targetCcrRight)
        currentCcrRight = (currentCcrRight + SPEED_STEP > targetCcrRight) ? targetCcrRight : currentCcrRight + SPEED_STEP;
    else if (currentCcrRight > targetCcrRight)
        currentCcrRight = (currentCcrRight < SPEED_STEP + targetCcrRight) ? targetCcrRight : currentCcrRight - SPEED_STEP;

    TIM3->CCR2 = (currentCcrLeft < 200) ? 0 : currentCcrLeft;
    TIM4->CCR2 = (currentCcrRight < 200) ? 0 : currentCcrRight;
}

// 모터 방향 초기화
void SetMotorDirection_Safe(void)
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
}

// 수동 모드 명령 처리
void ProcessManualCommand(void)
{
    currentMode = GetCurrentMode();  // 모드 갱신

    // ADC 값 처리
    if(newValueFlag)
    {
        newValueFlag = 0;
        targetCcrLeft  = rxADCValue;
        targetCcrRight = rxADCValue;

        char msg[50];
        sprintf(msg, "[ADC RX] Value: %d -> L:%d, R:%d\r\n", rxADCValue, targetCcrLeft, targetCcrRight);
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 50);
    }

    // 기존 문자 명령 처리
    if(rxData >= '1' && rxData <= '9')
    {
        uint8_t level = rxData - '0';
        uint16_t speed = level * 100;
        lastSpeed = speed;
        targetCcrLeft = speed;
        targetCcrRight = speed;

        char msg[60];
        sprintf(msg, "[MANUAL] Speed %d -> CCR %d\r\n", level, speed);
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 100);
    }
    else
    {
        SetMotorDirection_Safe();
        switch(rxData)
        {
            case 'F': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET); targetCcrLeft = lastSpeed; targetCcrRight = lastSpeed; break;
            case 'G': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET); targetCcrLeft = lastSpeed / 2; targetCcrRight = lastSpeed; break;
            case 'H': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET); targetCcrLeft = lastSpeed; targetCcrRight = lastSpeed / 2; break;
            case 'B': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); targetCcrLeft = lastSpeed; targetCcrRight = lastSpeed; break;
            case 'I': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); targetCcrLeft = lastSpeed / 2; targetCcrRight = lastSpeed; break;
            case 'J': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); targetCcrLeft = lastSpeed; targetCcrRight = lastSpeed / 2; break;
            case 'R': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); targetCcrLeft = lastSpeed; targetCcrRight = lastSpeed; break;
            case 'L': HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET); targetCcrLeft = lastSpeed; targetCcrRight = lastSpeed; break;
            case 'S':
            case '0': targetCcrLeft = 0; targetCcrRight = 0; break;
        }

        char msg[60];
        sprintf(msg, "[MANUAL] %c -> L:%d, R:%d\r\n", rxData, targetCcrLeft, targetCcrRight);
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 50);
    }
}

// 모터 제어 메인
void ProcessMotorCommand(void)
{
    if(toggleModeFlag)
    {
        toggleModeFlag = 0;

        if(currentMode == MODE_MANUAL)
        {
            currentMode = MODE_AUTO;
            SetMotorDirection_Safe();
            targetCcrLeft = 0;
            targetCcrRight = 0;
            char msg[] = "[MODE] MANUAL -> AUTO (Toggle)\r\n";
            HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 100);
        }
        else
        {
            currentMode = MODE_MANUAL;
            SetMotorDirection_Safe();
            targetCcrLeft = 0;
            targetCcrRight = 0;
            char msg[] = "[MODE] AUTO -> MANUAL (Toggle)\r\n";
            HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 100);
        }
        osDelay(50);
    }

    if(currentMode == MODE_MANUAL)
        ProcessManualCommand();
    else if(currentMode == MODE_AUTO)
    {
        HandleDistanceAndAutoBehavior();

        if(newValueFlag && (rxData == 'S' || rxData == '0'))
        {
            newValueFlag = 0;
            SetMotorDirection_Safe();
            targetCcrLeft = 0;
            targetCcrRight = 0;
            char msg[] = "[AUTO] Emergency Stop\r\n";
            HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 100);
        }
    }

    UpdateMotorSpeed();
}

// 모터 초기화
void Motor_Init(void)
{
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);

    currentCcrLeft = 0;
    currentCcrRight = 0;
    targetCcrLeft = 0;
    targetCcrRight = 0;

    SetMotorDirection_Safe();

    currentMode = GetCurrentMode();

    HAL_UART_Receive_IT(&huart1, &rxData, 1);

    char msg[40];
    sprintf(msg, "[INIT] Mode: %s\r\n", (currentMode == MODE_AUTO) ? "AUTO" : "MANUAL");
    HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 100);
}
